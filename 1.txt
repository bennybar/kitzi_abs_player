=== ./lib/ui/settings/settings_page.dart ===
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../main.dart';

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  static const _wifiOnlyKey = 'downloads_wifi_only';
  bool _wifiOnly = true;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() => _wifiOnly = prefs.getBool(_wifiOnlyKey) ?? true);
  }

  Future<void> _save(bool v) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_wifiOnlyKey, v);
  }

  @override
  Widget build(BuildContext context) {
    final theme = ServicesScope.of(context).services.theme;

    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          SwitchListTile(
            title: const Text('Dark mode'),
            value: theme.isDark,
            onChanged: (v) => theme.setDark(v),
          ),
          const Divider(),
          SwitchListTile(
            title: const Text('Wi-Fi only downloads'),
            subtitle: const Text('If off, uses Wi-Fi + Cellular'),
            value: _wifiOnly,
            onChanged: (v) async {
              setState(() => _wifiOnly = v);
              await _save(v);
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('Downloads will use ${v ? 'Wi-Fi only' : 'Wi-Fi + Cellular'}')),
                );
              }
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout),
            title: const Text('Log out'),
            onTap: () async {
              final services = ServicesScope.of(context).services;
              await services.auth.logout();
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Logged out')),
                );
              }
            },
          ),
        ],
      ),
    );
  }
}

=== ./lib/ui/home/books_page.dart ===
import 'dart:async';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../core/books_repository.dart';
import '../../models/book.dart';
import '../book_detail/book_detail_page.dart';

enum LibraryView { grid, list }
enum SortMode { nameAsc, addedDesc }

class BooksPage extends StatefulWidget {
  const BooksPage({super.key});

  @override
  State<BooksPage> createState() => _BooksPageState();
}

class _BooksPageState extends State<BooksPage> {
  late final Future<BooksRepository> _repoFut;
  List<Book> _books = [];
  bool _loading = true;
  String? _error;
  Timer? _timer;

  LibraryView _view = LibraryView.grid;
  SortMode _sort = SortMode.addedDesc;
  String _query = '';

  static const _viewKey = 'library_view_pref';
  static const _sortKey = 'library_sort_pref';
  static const _searchKey = 'library_search_pref';

  final _searchCtrl = TextEditingController();

  @override
  void initState() {
    super.initState();
    _repoFut = BooksRepository.create();
    _restorePrefs().then((_) {
      _refresh(initial: true);
      _setupAutoRefresh();
    });
  }

  @override
  void dispose() {
    _timer?.cancel();
    _searchCtrl.dispose();
    super.dispose();
  }

  Future<void> _restorePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final v = prefs.getString(_viewKey);
    final s = prefs.getString(_sortKey);
    final q = prefs.getString(_searchKey);

    if (v == 'list') _view = LibraryView.list;
    if (s == 'nameAsc') _sort = SortMode.nameAsc;
    if (q != null) {
      _query = q;
      _searchCtrl.text = q;
    }
  }

  Future<void> _saveViewPref(LibraryView v) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_viewKey, v == LibraryView.grid ? 'grid' : 'list');
  }

  Future<void> _saveSortPref(SortMode s) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(
        _sortKey, s == SortMode.nameAsc ? 'nameAsc' : 'addedDesc');
  }

  Future<void> _saveSearchPref(String q) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_searchKey, q);
  }

  void _setupAutoRefresh() {
    _timer = Timer.periodic(const Duration(minutes: 1), (_) => _refresh());
  }

  Future<void> _refresh({bool initial = false}) async {
    setState(() {
      if (initial) _loading = true;
      _error = null;
    });
    try {
      final repo = await _repoFut;
      final items = await repo.listBooks();
      if (!mounted) return;
      setState(() {
        _books = items;
        _loading = false;
      });
      _warmCacheCovers(items);
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _error = e.toString();
        _loading = false;
      });
    }
  }

  /// Pre-cache first N covers to disk/memory for snappy grid/list.
  void _warmCacheCovers(List<Book> items, {int count = 30}) {
    if (!mounted || items.isEmpty) return;
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      for (final b in items.take(count)) {
        // Fire-and-forget; CachedNetworkImage handles disk cache
        precacheImage(CachedNetworkImageProvider(b.coverUrl), context)
            .catchError((_) {});
      }
    });
  }

  void _openDetails(Book b) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (_) => BookDetailPage(bookId: b.id)),
    );
  }

  List<Book> _visibleBooks() {
    final q = _query.trim().toLowerCase();
    List<Book> list = q.isEmpty
        ? List<Book>.from(_books)
        : _books.where((b) {
      final t = b.title.toLowerCase();
      final a = (b.author ?? '').toLowerCase();
      return t.contains(q) || a.contains(q);
    }).toList();

    switch (_sort) {
      case SortMode.nameAsc:
        list.sort(
                (a, b) => a.title.toLowerCase().compareTo(b.title.toLowerCase()));
        break;
      case SortMode.addedDesc:
        list.sort((a, b) {
          final da = a.updatedAt;
          final db = b.updatedAt;
          if (da == null && db == null) return 0;
          if (da == null) return 1;
          if (db == null) return -1;
          return db.compareTo(da);
        });
        break;
    }
    return list;
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final visible = _visibleBooks();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Books'),
        actions: [
          IconButton(
            tooltip: 'Refresh',
            onPressed: _loading ? null : () => _refresh(),
            icon: const Icon(Icons.refresh),
          ),
          PopupMenuButton<SortMode>(
            tooltip: 'Sort',
            initialValue: _sort,
            onSelected: (mode) {
              setState(() => _sort = mode);
              _saveSortPref(mode);
            },
            itemBuilder: (context) => const [
              PopupMenuItem(
                value: SortMode.addedDesc,
                child: ListTile(
                  leading: Icon(Icons.schedule),
                  title: Text('Added date (newest)'),
                ),
              ),
              PopupMenuItem(
                value: SortMode.nameAsc,
                child: ListTile(
                  leading: Icon(Icons.sort_by_alpha),
                  title: Text('Name (A–Z)'),
                ),
              ),
            ],
            icon: const Icon(Icons.sort),
          ),
          const SizedBox(width: 8),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(56),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
            child: SearchBar(
              controller: _searchCtrl,
              leading: const Icon(Icons.search),
              hintText: 'Search title or author',
              onChanged: (val) {
                setState(() => _query = val);
                _saveSearchPref(val);
              },
              trailing: [
                if (_query.isNotEmpty)
                  IconButton(
                    tooltip: 'Clear',
                    onPressed: () {
                      _searchCtrl.clear();
                      setState(() => _query = '');
                      _saveSearchPref('');
                    },
                    icon: const Icon(Icons.clear),
                  ),
                SegmentedButton<LibraryView>(
                  segments: const [
                    ButtonSegment(
                        value: LibraryView.grid, icon: Icon(Icons.grid_view)),
                    ButtonSegment(
                        value: LibraryView.list, icon: Icon(Icons.view_list)),
                  ],
                  selected: {_view},
                  onSelectionChanged: (sel) {
                    final v = sel.first;
                    setState(() => _view = v);
                    _saveViewPref(v);
                  },
                ),
              ],
            ),
          ),
        ),
      ),
      body: RefreshIndicator(
        onRefresh: _refresh,
        child: _loading
            ? const Center(child: CircularProgressIndicator())
            : _error != null
            ? ListView(
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text('Error: $_error',
                  style: TextStyle(color: cs.error)),
            ),
          ],
        )
            : (_view == LibraryView.grid
            ? _buildGrid(visible)
            : _buildList(visible)),
      ),
    );
  }

  Widget _buildGrid(List<Book> list) {
    return GridView.builder(
      padding: const EdgeInsets.all(12),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 3,
        mainAxisSpacing: 12,
        crossAxisSpacing: 12,
        childAspectRatio: 0.66,
      ),
      itemCount: list.length,
      itemBuilder: (context, i) {
        final b = list[i];
        return _BookTile(
          book: b,
          onTap: () => _openDetails(b),
        );
      },
    );
  }

  Widget _buildList(List<Book> list) {
    return ListView.separated(
      padding: const EdgeInsets.all(8),
      itemCount: list.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, i) {
        final b = list[i];
        return ListTile(
          leading: _CoverThumb(url: b.coverUrl, size: 56),
          title: Text(b.title, maxLines: 1, overflow: TextOverflow.ellipsis),
          subtitle: Text(b.author ?? 'Unknown'),
          onTap: () => _openDetails(b),
        );
      },
    );
  }
}

class _BookTile extends StatelessWidget {
  const _BookTile({required this.book, required this.onTap});
  final Book book;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(child: _CoverThumb(url: book.coverUrl)),
          const SizedBox(height: 6),
          Text(
            book.title,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          Text(
            book.author ?? '',
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }
}

class _CoverThumb extends StatelessWidget {
  const _CoverThumb({required this.url, this.size});
  final String url;
  final double? size;

  @override
  Widget build(BuildContext context) {
    final radius = BorderRadius.circular(12);
    final placeholder = DecoratedBox(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: radius,
      ),
      child: const Center(child: Icon(Icons.menu_book_outlined)),
    );

    final img = CachedNetworkImage(
      imageUrl: url,
      fit: BoxFit.cover,
      placeholder: (_, __) => placeholder,
      errorWidget: (_, __, ___) => placeholder,
    );

    return ClipRRect(
      borderRadius: radius,
      child: size != null
          ? SizedBox(width: size, height: size, child: img)
          : img,
    );
  }
}

=== ./lib/ui/auth/login_page.dart ===
import 'package:flutter/material.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key, this.onRetryCheck});

  /// Called when user taps "Retry" (lets AuthGate re-check token)
  final Future<void> Function()? onRetryCheck;

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  @override
  Widget build(BuildContext context) {
    final text = Theme.of(context).textTheme;
    return Scaffold(
      appBar: AppBar(title: const Text('Sign in')),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 420),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text('You’re signed out', style: text.headlineSmall),
                const SizedBox(height: 8),
                Text(
                  'Please open Settings and sign in to your Audiobookshelf server. '
                      'When you’re done, return here and tap Retry.',
                  style: text.bodyMedium,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 20),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () {
                          // If your app already has a settings route, push it.
                          // Adjust the route name if different in your app.
                          Navigator.of(context).pushNamed('/settings');
                        },
                        icon: const Icon(Icons.settings),
                        label: const Text('Open Settings'),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: widget.onRetryCheck,
                        icon: const Icon(Icons.refresh),
                        label: const Text('Retry'),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

=== ./lib/ui/auth/auth_gate.dart ===
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../core/auth_repository.dart';
import '../../main.dart'; // ServicesScope
import 'login_page.dart';

/// Wrap your real app with [AuthGate]. If there is no valid session, it shows
/// the LoginPage; otherwise it shows [child].
class AuthGate extends StatefulWidget {
  const AuthGate({super.key, required this.child});
  final Widget child;

  @override
  State<AuthGate> createState() => _AuthGateState();
}

class _AuthGateState extends State<AuthGate> with WidgetsBindingObserver {
  late final AuthRepository _auth;
  bool? _isLoggedIn;
  Timer? _poll;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _auth = ServicesScope.of(context).services.auth;
    _check();
    _poll ??= Timer.periodic(const Duration(seconds: 15), (_) => _check());
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _poll?.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      SchedulerBinding.instance.addPostFrameCallback((_) => _check());
    }
  }

  Future<void> _check() async {
    try {
      final token = await _auth.api.accessToken();
      final isValid = token != null && token.isNotEmpty;
      if (!mounted) return;
      setState(() => _isLoggedIn = isValid);
    } catch (_) {
      if (!mounted) return;
      setState(() => _isLoggedIn = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoggedIn == null) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }
    if (_isLoggedIn == false) {
      return LoginPage(onRetryCheck: _check);
    }
    return widget.child;
  }
}

=== ./lib/ui/main/main_scaffold.dart ===
import 'package:flutter/material.dart';

import '../settings/settings_page.dart';
import '../home/books_page.dart';
import '../downloads/downloads_page.dart';
import '../player/mini_player.dart';

import '../../core/downloads_repository.dart';
import '../../core/playback_repository.dart';
import '../../main.dart';

class MainScaffold extends StatefulWidget {
  const MainScaffold({super.key, required this.downloadsRepo});
  final DownloadsRepository downloadsRepo;

  @override
  State<MainScaffold> createState() => _MainScaffoldState();
}

class _MainScaffoldState extends State<MainScaffold> {
  int _index = 0;

  @override
  Widget build(BuildContext context) {
    final services = ServicesScope.of(context).services;
    final playback = services.playback;

    final pages = <Widget>[
      const BooksPage(),
      DownloadsPage(repo: widget.downloadsRepo),
      const SettingsPage(),
    ];

    return StreamBuilder<NowPlaying?>(
      stream: playback.nowPlayingStream,
      initialData: playback.nowPlaying,
      builder: (_, snap) {
        final hasMini = snap.data != null;

        return Scaffold(
          body: Stack(
            children: [
              Positioned.fill(
                child: Padding(
                  // leave room for the mini-player (64px) + a bit of spacing
                  padding: EdgeInsets.only(bottom: hasMini ? 72 : 0),
                  child: pages[_index],
                ),
              ),
              if (hasMini)
                Align(
                  alignment: Alignment.bottomCenter,
                  child: SafeArea(
                    top: false,
                    child: MiniPlayer(playback: playback),
                  ),
                ),
            ],
          ),
          bottomNavigationBar: NavigationBar(
            selectedIndex: _index,
            onDestinationSelected: (i) => setState(() => _index = i),
            destinations: const [
              NavigationDestination(
                icon: Icon(Icons.library_books_outlined),
                label: 'Books',
              ),
              NavigationDestination(
                icon: Icon(Icons.download_outlined),
                label: 'Downloads',
              ),
              NavigationDestination(
                icon: Icon(Icons.settings_outlined),
                label: 'Settings',
              ),
            ],
          ),
        );
      },
    );
  }
}

=== ./lib/ui/book_detail/book_detail_page.dart ===
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:background_downloader/background_downloader.dart';

import '../../core/books_repository.dart';
import '../../models/book.dart';
import '../../core/downloads_repository.dart';
import '../../core/playback_repository.dart';
import '../../widgets/mini_player.dart';
import '../../widgets/download_button.dart';
import '../../main.dart'; // ServicesScope

class BookDetailPage extends StatefulWidget {
  const BookDetailPage({super.key, required this.bookId});
  final String bookId;

  @override
  State<BookDetailPage> createState() => _BookDetailPageState();
}

class _BookDetailPageState extends State<BookDetailPage> {
  late final Future<BooksRepository> _repoFut;
  Future<Book>? _bookFut;
  Future<double?>? _serverProgressFut;

  @override
  void initState() {
    super.initState();
    _repoFut = BooksRepository.create();
    _bookFut = _repoFut.then((r) => r.getBook(widget.bookId));
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final pb = ServicesScope.of(context).services.playback;
    _serverProgressFut ??= pb.fetchServerProgress(widget.bookId);
  }

  @override
  Widget build(BuildContext context) {
    final services = ServicesScope.of(context).services;
    final playbackRepo = services.playback;
    final downloadsRepo = services.downloads;

    final cs = Theme.of(context).colorScheme;
    final text = Theme.of(context).textTheme;

    return Scaffold(
      appBar: AppBar(title: const Text('Book details')),
      body: Stack(
        children: [
          FutureBuilder<Book>(
            future: _bookFut,
            builder: (context, snap) {
              if (snap.connectionState != ConnectionState.done) {
                return const Center(child: CircularProgressIndicator());
              }
              if (snap.hasError || !snap.hasData) {
                return Center(
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Text(
                      'Failed to load book.',
                      style: TextStyle(color: cs.error),
                    ),
                  ),
                );
              }

              final b = snap.data!;

              String fmtDuration() {
                if (b.durationMs == null || b.durationMs == 0) return 'Unknown';
                final d = Duration(milliseconds: b.durationMs!);
                final h = d.inHours;
                final m = d.inMinutes.remainder(60).toString().padLeft(2, '0');
                return h > 0 ? '$h h $m m' : '$m m';
              }

              String fmtSize() {
                if (b.sizeBytes == null || b.sizeBytes == 0) return '—';
                final mb = (b.sizeBytes! / (1024 * 1024));
                return '${mb.toStringAsFixed(1)} MB';
              }

              return Padding(
                padding: const EdgeInsets.only(bottom: 112), // room for mini player
                child: CustomScrollView(
                  slivers: [
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            ClipRRect(
                              borderRadius: BorderRadius.circular(12),
                              child: CachedNetworkImage(
                                imageUrl: b.coverUrl,
                                width: 140,
                                height: 210,
                                fit: BoxFit.cover,
                                errorWidget: (_, __, ___) => Container(
                                  width: 140,
                                  height: 210,
                                  alignment: Alignment.center,
                                  color: cs.surfaceContainerHighest,
                                  child: const Icon(Icons.menu_book_outlined, size: 48),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(b.title, style: text.titleLarge, maxLines: 2, overflow: TextOverflow.ellipsis),
                                  const SizedBox(height: 6),
                                  Text(b.author ?? 'Unknown author', style: text.titleMedium),
                                  const SizedBox(height: 12),
                                  Wrap(
                                    spacing: 8,
                                    runSpacing: 8,
                                    children: [
                                      _InfoChip(icon: Icons.schedule, label: fmtDuration()),
                                      _InfoChip(icon: Icons.save_alt, label: fmtSize()),
                                      if (b.updatedAt != null)
                                        _InfoChip(icon: Icons.update, label: b.updatedAt!.toLocal().toString().split('.').first),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: _ListeningProgress(
                          playback: playbackRepo,
                          book: b,
                          serverProgressFuture: _serverProgressFut!,
                        ),
                      ),
                    ),
                    if (b.description != null && b.description!.isNotEmpty)
                      SliverToBoxAdapter(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text('Description', style: text.titleMedium),
                              const SizedBox(height: 8),
                              Text(b.description!, style: text.bodyMedium),
                            ],
                          ),
                        ),
                      ),
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 20, 16, 16),
                        child: Row(
                          children: [
                            Expanded(
                              child: FilledButton.icon(
                                onPressed: () async {
                                  await playbackRepo.playItem(b.id);
                                  if (!context.mounted) return;
                                  Navigator.of(context).pushNamed('/player');
                                },
                                icon: const Icon(Icons.play_arrow),
                                label: const Text('Play'),
                              ),
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: DownloadButton(
                                libraryItemId: b.id,
                                titleForNotification: b.title,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    // Optional inline per-book progress strip (kept)
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
                        child: StreamBuilder<TaskUpdate>(
                          stream: downloadsRepo.progressStream(),
                          builder: (_, snapUp) {
                            if (!snapUp.hasData) return const SizedBox.shrink();
                            final up = snapUp.data!;
                            final metaStr = up.task.metaData ?? '';
                            final isThisBook = metaStr.contains(b.id);
                            if (!isThisBook) return const SizedBox.shrink();

                            double? progressValue;
                            String statusText = 'running';

                            if (up is TaskProgressUpdate) {
                              progressValue = up.progress;
                            } else if (up is TaskStatusUpdate) {
                              statusText = up.status.name;
                              progressValue = null; // indeterminate
                            }

                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                LinearProgressIndicator(value: progressValue),
                                const SizedBox(height: 4),
                                Text(
                                  progressValue != null
                                      ? 'Download: $statusText • ${(progressValue * 100).toStringAsFixed(0)}%'
                                      : 'Download: $statusText',
                                ),
                              ],
                            );
                          },
                        ),
                      ),
                    ),
                  ],
                ),
              );
            },
          ),

          // Mini player
          Align(
            alignment: Alignment.bottomCenter,
            child: SafeArea(
              top: false,
              child: MiniPlayer(height: 112),
            ),
          ),
        ],
      ),
    );
  }
}

class _InfoChip extends StatelessWidget {
  const _InfoChip({required this.icon, required this.label});
  final IconData icon;
  final String label;

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(999),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: cs.onSurfaceVariant),
          const SizedBox(width: 6),
          Text(label, style: Theme.of(context).textTheme.labelLarge),
        ],
      ),
    );
  }
}

// ---------- Listening Progress ----------
class _ListeningProgress extends StatelessWidget {
  const _ListeningProgress({
    required this.playback,
    required this.book,
    required this.serverProgressFuture,
  });

  final PlaybackRepository playback;
  final Book book;
  final Future<double?> serverProgressFuture;

  @override
  Widget build(BuildContext context) {
    final isThis = playback.nowPlaying?.libraryItemId == book.id;

    if (isThis) {
      return StreamBuilder<Duration?>(
        stream: playback.durationStream,
        initialData: playback.player.duration,
        builder: (_, dSnap) {
          final total = dSnap.data ?? Duration.zero;
          return StreamBuilder<Duration>(
            stream: playback.positionStream,
            initialData: playback.player.position,
            builder: (_, pSnap) {
              final pos = pSnap.data ?? Duration.zero;
              final v = (total.inMilliseconds > 0)
                  ? pos.inMilliseconds / total.inMilliseconds
                  : 0.0;
              return _progressTile(
                context,
                value: v,
                left: _fmt(pos),
                right: total == Duration.zero ? '' : '-${_fmt(total - pos)}',
              );
            },
          );
        },
      );
    }

    return FutureBuilder<double?>(
      future: serverProgressFuture,
      builder: (_, snap) {
        final sec = (snap.data ?? 0.0);
        final durMs = book.durationMs ?? 0;
        final totalSec = durMs / 1000.0;
        final v = (totalSec > 0) ? (sec / totalSec).clamp(0.0, 1.0) : 0.0;
        return _progressTile(
          context,
          value: v,
          left: _fmt(Duration(milliseconds: (sec * 1000).round())),
          right: (totalSec > 0)
              ? '-${_fmt(Duration(milliseconds: (totalSec * 1000 - sec * 1000).round()))}'
              : '',
        );
      },
    );
  }

  Widget _progressTile(BuildContext context,
      {required double value, required String left, required String right}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text('Listening progress', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 6),
        LinearProgressIndicator(value: value),
        const SizedBox(height: 4),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(left, style: Theme.of(context).textTheme.labelLarge),
            Text(right, style: Theme.of(context).textTheme.labelLarge),
          ],
        ),
      ],
    );
  }

  String _fmt(Duration d) {
    final h = d.inHours;
    final m = d.inMinutes.remainder(60).toString().padLeft(2, '0');
    final s = d.inSeconds.remainder(60).toString().padLeft(2, '0');
    return h > 0 ? '$h:$m:$s' : '$m:$s';
  }
}

=== ./lib/ui/downloads/downloads_page.dart ===
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:background_downloader/background_downloader.dart';
import '../../core/downloads_repository.dart';

class DownloadsPage extends StatefulWidget {
  const DownloadsPage({super.key, required this.repo});
  final DownloadsRepository repo;

  @override
  State<DownloadsPage> createState() => _DownloadsPageState();
}

class _DownloadsPageState extends State<DownloadsPage> {
  late final Stream<TaskUpdate> _updates;
  StreamSubscription<TaskUpdate>? _sub;

  // latest update by taskId so we can show immediate progress
  final Map<String, TaskUpdate> _latest = {};

  @override
  void initState() {
    super.initState();
    // make sure repo is initialized (no-op if already)
    widget.repo.init();

    _updates = widget.repo.progressStream();
    _sub = _updates.listen((u) {
      _latest[u.task.taskId] = u;
      if (mounted) setState(() {}); // trigger rebuild
    });
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // We rebuild on each stream event via setState above.
    return FutureBuilder<List<TaskRecord>>(
      future: widget.repo.listAll(),
      builder: (context, recs) {
        final items = recs.data ?? const [];
        if (items.isEmpty) {
          return const Center(child: Text('No downloads'));
        }
        return ListView.separated(
          itemCount: items.length,
          separatorBuilder: (_, __) => const Divider(height: 1),
          itemBuilder: (ctx, i) {
            final r = items[i];
            final task = r.task;

            // start with DB snapshot
            double progress = r.progress ?? 0.0;
            String status = r.status.name;

            // prefer latest live update if we have it
            final live = _latest[task.taskId];
            if (live is TaskProgressUpdate) {
              progress = live.progress;
              status = 'running';
            } else if (live is TaskStatusUpdate) {
              status = live.status.name;
            }

            final isTerminal = status == 'complete' || status == 'failed' || status == 'canceled';

            return ListTile(
              title: Text(task.filename),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  LinearProgressIndicator(value: isTerminal ? 1.0 : progress),
                  const SizedBox(height: 4),
                  Text('$status • ${(progress * 100).toStringAsFixed(0)}%'),
                ],
              ),
              trailing: IconButton(
                icon: const Icon(Icons.cancel),
                onPressed: () => FileDownloader().cancelTaskWithId(r.taskId),
              ),
            );
          },
        );
      },
    );
  }
}


=== ./lib/ui/login/login_screen.dart ===
import 'package:flutter/material.dart';
import '../../core/auth_repository.dart';
import '../../main.dart';
import '../main/main_scaffold.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key, required this.auth});
  final AuthRepository auth;

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _form = GlobalKey<FormState>();
  final _serverCtrl = TextEditingController();
  final _userCtrl = TextEditingController();
  final _passCtrl = TextEditingController();
  bool _loading = false;
  String? _error;

  @override
  void dispose() {
    _serverCtrl.dispose();
    _userCtrl.dispose();
    _passCtrl.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_form.currentState!.validate()) return;
    setState(() {
      _loading = true;
      _error = null;
    });

    String normalizeBaseUrl(String input) {
      var url = input.trim();
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://$url';
      }
      return url.replaceAll(RegExp(r'/+$'), '');
    }

    final ok = await widget.auth.login(
      baseUrl: normalizeBaseUrl(_serverCtrl.text),
      username: _userCtrl.text.trim(),
      password: _passCtrl.text,
    );




    if (!mounted) return;
    setState(() => _loading = false);

    // after a successful login:
    if (ok) {
      final services = ServicesScope.of(context).services;
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (_) => MainScaffold(downloadsRepo: services.downloads),
        ),
      );
    } else {
      setState(() => _error = 'Login failed. Check server URL and credentials.');
    }

  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 420),
          child: Card(
            elevation: 0,
            color: cs.surfaceContainerHighest,
            margin: const EdgeInsets.all(16),
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Form(
                key: _form,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextFormField(
                      controller: _serverCtrl,
                      decoration: const InputDecoration(
                        labelText: 'Server URL',
                        hintText: 'https://abs.example.com',
                      ),
                      keyboardType: TextInputType.url,
                      validator: (v) =>
                      (v == null || v.trim().isEmpty) ? 'Required' : null,
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: _userCtrl,
                      decoration: const InputDecoration(labelText: 'Username'),
                      validator: (v) =>
                      (v == null || v.trim().isEmpty) ? 'Required' : null,
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: _passCtrl,
                      decoration: const InputDecoration(labelText: 'Password'),
                      obscureText: true,
                      validator: (v) =>
                      (v == null || v.isEmpty) ? 'Required' : null,
                    ),
                    const SizedBox(height: 16),
                    if (_error != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Text(_error!, style: TextStyle(color: cs.error)),
                      ),
                    FilledButton(
                      onPressed: _loading ? null : _submit,
                      child: _loading
                          ? const SizedBox(
                        height: 18,
                        width: 18,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                          : const Text('Sign in'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

=== ./lib/ui/player/full_player_page.dart ===
import 'dart:async';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:just_audio/just_audio.dart';

import '../../core/playback_repository.dart';
import '../../main.dart';

class FullPlayerPage extends StatefulWidget {
  const FullPlayerPage({super.key});

  @override
  State<FullPlayerPage> createState() => _FullPlayerPageState();
}

class _FullPlayerPageState extends State<FullPlayerPage> {
  late final PlaybackRepository _pb;
  bool _dragging = false;
  double _pendingSeekMs = -1;
  Timer? _coalesce;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _pb = ServicesScope.of(context).services.playback;
  }

  @override
  void dispose() {
    _coalesce?.cancel();
    super.dispose();
  }

  Future<void> _commitSeek() async {
    if (_pendingSeekMs >= 0) {
      final ms = _pendingSeekMs;
      _pendingSeekMs = -1;
      await _pb.seek(Duration(milliseconds: ms.round()), reportNow: true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final text = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: cs.surface,
      appBar: AppBar(
        title: const Text('Now Playing'),
        leading: IconButton(
          icon: const Icon(Icons.keyboard_arrow_down),
          onPressed: () => Navigator.of(context).maybePop(),
          tooltip: 'Dismiss',
        ),
      ),
      body: SafeArea(
        child: StreamBuilder<NowPlaying?>(
          stream: _pb.nowPlayingStream,
          initialData: _pb.nowPlaying,
          builder: (_, snap) {
            final np = snap.data;
            if (np == null) {
              return const Center(child: Text('Nothing playing'));
            }

            return Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    children: [
                      ClipRRect(
                        borderRadius: BorderRadius.circular(12),
                        child: CachedNetworkImage(
                          imageUrl: np.coverUrl ?? '',
                          width: 120,
                          height: 120,
                          fit: BoxFit.cover,
                          errorWidget: (_, __, ___) => Container(
                            width: 120,
                            height: 120,
                            color: cs.surfaceContainerHighest,
                            child: const Icon(Icons.audiotrack, size: 40),
                          ),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(np.title, style: text.titleLarge, maxLines: 2, overflow: TextOverflow.ellipsis),
                            const SizedBox(height: 6),
                            Text(np.author ?? '', style: text.titleMedium, maxLines: 1, overflow: TextOverflow.ellipsis),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const Spacer(),
                  StreamBuilder<Duration?>(
                    stream: _pb.durationStream,
                    initialData: _pb.player.duration,
                    builder: (_, dSnap) {
                      final total = dSnap.data ?? Duration.zero;
                      return StreamBuilder<Duration>(
                        stream: _pb.positionStream,
                        initialData: _pb.player.position,
                        builder: (_, pSnap) {
                          final pos = pSnap.data ?? Duration.zero;
                          final max = (total.inMilliseconds > 0)
                              ? total.inMilliseconds.toDouble()
                              : 1.0;
                          final value = _dragging
                              ? _pendingSeekMs.clamp(0.0, max)
                              : pos.inMilliseconds
                              .clamp(0, total.inMilliseconds)
                              .toDouble();

                          String fmt(Duration d) {
                            final h = d.inHours;
                            final m = d.inMinutes.remainder(60).toString().padLeft(2, '0');
                            final s = d.inSeconds.remainder(60).toString().padLeft(2, '0');
                            return h > 0 ? '$h:$m:$s' : '$m:$s';
                          }

                          return Column(
                            children: [
                              Slider(
                                min: 0,
                                max: max,
                                value: value,
                                onChangeStart: (_) {
                                  _dragging = true;
                                  _coalesce?.cancel();
                                },
                                onChanged: (v) {
                                  _pendingSeekMs = v;
                                  _coalesce?.cancel();
                                  _coalesce = Timer(const Duration(milliseconds: 350), _commitSeek);
                                  setState(() {});
                                },
                                onChangeEnd: (_) async {
                                  _dragging = false;
                                  await _commitSeek();
                                },
                              ),
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text(fmt(Duration(milliseconds: value.round()))),
                                  Text(total == Duration.zero
                                      ? ''
                                      : '-${fmt(total - Duration(milliseconds: value.round()))}'),
                                ],
                              ),
                            ],
                          );
                        },
                      );
                    },
                  ),
                  const SizedBox(height: 12),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      IconButton(
                        iconSize: 32,
                        icon: const Icon(Icons.replay_10),
                        onPressed: () => _pb.nudgeSeconds(-10),
                      ),
                      const SizedBox(width: 8),
                      StreamBuilder<bool>(
                        stream: _pb.playingStream,
                        initialData: _pb.player.playing,
                        builder: (_, playSnap) {
                          final playing = playSnap.data ?? false;
                          return FilledButton.icon(
                            onPressed: () => playing ? _pb.pause() : _pb.resume(),
                            icon: Icon(playing ? Icons.pause : Icons.play_arrow),
                            label: Text(playing ? 'Pause' : 'Play'),
                          );
                        },
                      ),
                      const SizedBox(width: 8),
                      IconButton(
                        iconSize: 32,
                        icon: const Icon(Icons.forward_30),
                        onPressed: () => _pb.nudgeSeconds(30),
                      ),
                    ],
                  ),
                  const Spacer(),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
}

=== ./lib/ui/player/full_player_sheet.dart ===
import 'dart:async';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';

import '../../core/playback_repository.dart';

class FullPlayerSheet extends StatefulWidget {
  const FullPlayerSheet({super.key, required this.playback});
  final PlaybackRepository playback;

  @override
  State<FullPlayerSheet> createState() => _FullPlayerSheetState();
}

class _FullPlayerSheetState extends State<FullPlayerSheet> {
  double _speed = 1.0;
  Timer? _sleepTimer;
  String _sleepLabel = 'Sleep';

  @override
  void initState() {
    super.initState();
    _speed = widget.playback.player.speed;
  }

  @override
  void dispose() {
    _sleepTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final pb = widget.playback;

    return DraggableScrollableSheet(
      initialChildSize: 0.92,
      minChildSize: 0.5,
      maxChildSize: 0.96,
      expand: false,
      builder: (ctx, controller) {
        return DecoratedBox(
          decoration: BoxDecoration(
            color: cs.surface,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
            boxShadow: const [BoxShadow(blurRadius: 18, offset: Offset(0, -4))],
          ),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(20, 8, 20, 24),
            child: StreamBuilder<NowPlaying?>(
              stream: pb.nowPlayingStream,
              initialData: pb.nowPlaying,
              builder: (_, snap) {
                final np = snap.data;
                if (np == null) {
                  return const Center(child: Text('Nothing playing'));
                }

                final hasChapters = np.chapters.isNotEmpty;

                return ListView(
                  controller: controller,
                  children: [
                    Center(
                      child: Container(
                        height: 5,
                        width: 48,
                        margin: const EdgeInsets.only(bottom: 16),
                        decoration: BoxDecoration(
                          color: cs.outlineVariant,
                          borderRadius: BorderRadius.circular(3),
                        ),
                      ),
                    ),

                    // Cover
                    AspectRatio(
                      aspectRatio: 1,
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(16),
                        child: CachedNetworkImage(
                          imageUrl: np.coverUrl ?? '',
                          fit: BoxFit.cover,
                          errorWidget: (_, __, ___) => Container(
                            color: cs.surfaceContainerHighest,
                            child: const Center(
                              child: Icon(Icons.menu_book_outlined, size: 72),
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),

                    // Title/author
                    if (np.author != null && np.author!.isNotEmpty)
                      Text(
                        np.author!,
                        textAlign: TextAlign.center,
                        style: Theme.of(context)
                            .textTheme
                            .bodyMedium
                            ?.copyWith(color: cs.onSurfaceVariant),
                      ),
                    const SizedBox(height: 6),
                    Text(
                      np.title,
                      textAlign: TextAlign.center,
                      style: Theme.of(context)
                          .textTheme
                          .headlineSmall
                          ?.copyWith(fontWeight: FontWeight.w600),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 18),

                    // Slider + timecodes
                    StreamBuilder<Duration?>(
                      stream: pb.durationStream,
                      initialData: pb.player.duration,
                      builder: (_, dSnap) {
                        final total = dSnap.data ?? Duration.zero;
                        return StreamBuilder<Duration>(
                          stream: pb.positionStream,
                          initialData: pb.player.position,
                          builder: (_, pSnap) {
                            final pos = pSnap.data ?? Duration.zero;
                            final v = (total.inMilliseconds > 0)
                                ? pos.inMilliseconds / total.inMilliseconds
                                : 0.0;
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.stretch,
                              children: [
                                Slider(
                                  value: v.clamp(0.0, 1.0),
                                  onChanged: (nv) {
                                    final target = Duration(
                                      milliseconds:
                                      (total.inMilliseconds * nv).round(),
                                    );
                                    pb.seek(target, reportNow: false);
                                  },
                                  onChangeEnd: (nv) {
                                    final target = Duration(
                                      milliseconds:
                                      (total.inMilliseconds * nv).round(),
                                    );
                                    pb.seek(target, reportNow: true);
                                  },
                                ),
                                Row(
                                  mainAxisAlignment:
                                  MainAxisAlignment.spaceBetween,
                                  children: [
                                    Text(_fmt(pos),
                                        style: Theme.of(context)
                                            .textTheme
                                            .labelLarge),
                                    Text('-${_fmt(total - pos)}',
                                        style: Theme.of(context)
                                            .textTheme
                                            .labelLarge),
                                  ],
                                ),
                              ],
                            );
                          },
                        );
                      },
                    ),

                    const SizedBox(height: 12),

                    // Main controls
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        IconButton(
                          iconSize: 28,
                          icon: const Icon(Icons.skip_previous),
                          onPressed: pb.hasPrev ? pb.prevTrack : null,
                        ),
                        IconButton.filledTonal(
                          iconSize: 28,
                          onPressed: () => pb.nudgeSeconds(-15),
                          icon: const Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [Icon(Icons.replay), Text('15')],
                          ),
                        ),
                        StreamBuilder<bool>(
                          stream: pb.playingStream,
                          initialData: pb.player.playing,
                          builder: (_, s) {
                            final isPlaying = s.data ?? false;
                            return FilledButton(
                              style: FilledButton.styleFrom(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 28, vertical: 10),
                                  shape: const StadiumBorder()),
                              onPressed: isPlaying ? pb.pause : pb.resume,
                              child: Icon(
                                isPlaying
                                    ? Icons.pause_rounded
                                    : Icons.play_arrow_rounded,
                                size: 36,
                              ),
                            );
                          },
                        ),
                        IconButton.filledTonal(
                          iconSize: 28,
                          onPressed: () => pb.nudgeSeconds(15),
                          icon: const Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [Icon(Icons.forward), Text('15')],
                          ),
                        ),
                        IconButton(
                          iconSize: 28,
                          icon: const Icon(Icons.skip_next),
                          onPressed: pb.hasNext ? pb.nextTrack : null,
                        ),
                      ],
                    ),

                    const SizedBox(height: 10),

                    // Chapter controls row
                    if (np.chapters.isNotEmpty)
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                        children: [
                          TextButton.icon(
                            onPressed: _prevChapter,
                            icon: const Icon(Icons.skip_previous_rounded),
                            label: const Text('Chapter'),
                          ),
                          FilledButton.tonalIcon(
                            onPressed: _showChapters,
                            icon: const Icon(Icons.list),
                            label: const Text('Chapters'),
                          ),
                          TextButton.icon(
                            onPressed: _nextChapter,
                            icon: const Icon(Icons.skip_next_rounded),
                            label: const Text('Chapter'),
                          ),
                        ],
                      ),

                    const SizedBox(height: 12),

                    // Speed / Sleep row
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        TextButton.icon(
                          onPressed: _pickSpeed,
                          icon: const Icon(Icons.speed),
                          label: Text('${_speed.toStringAsFixed(2)}x'),
                        ),
                        TextButton.icon(
                          onPressed: _pickSleep,
                          icon: const Icon(Icons.nightlight_round),
                          label: Text(_sleepLabel),
                        ),
                      ],
                    ),
                  ],
                );
              },
            ),
          ),
        );
      },
    );
  }

  String _fmt(Duration d) {
    final h = d.inHours;
    final m = d.inMinutes.remainder(60).toString().padLeft(2, '0');
    final s = d.inSeconds.remainder(60).toString().padLeft(2, '0');
    return h > 0 ? '$h:$m:$s' : '$m:$s';
  }

  // ------ Speed / Sleep ------
  Future<void> _pickSpeed() async {
    final v = await showModalBottomSheet<double>(
      context: context,
      builder: (_) => _SpeedSheet(current: _speed),
    );
    if (v != null) {
      setState(() => _speed = v);
      await widget.playback.setSpeed(v);
    }
  }

  Future<void> _pickSleep() async {
    final v = await showModalBottomSheet<Duration?>(
      context: context,
      builder: (_) => const _SleepSheet(),
    );
    _sleepTimer?.cancel();
    if (v != null) {
      setState(() => _sleepLabel = '${v.inMinutes} min');
      _sleepTimer = Timer(v, () {
        widget.playback.pause();
        if (mounted) setState(() => _sleepLabel = 'Sleep');
      });
    } else {
      if (mounted) setState(() => _sleepLabel = 'Sleep');
    }
  }

  // ------ Chapters ------
  void _showChapters() {
    final np = widget.playback.nowPlaying;
    if (np == null || np.chapters.isEmpty) return;
    showModalBottomSheet(
      context: context,
      builder: (_) => ListView.separated(
        padding: const EdgeInsets.all(12),
        itemCount: np.chapters.length,
        separatorBuilder: (_, __) => const Divider(height: 1),
        itemBuilder: (_, i) {
          final c = np.chapters[i];
          return ListTile(
            leading: Text('${i + 1}'),
            title: Text(c.title, maxLines: 2, overflow: TextOverflow.ellipsis),
            trailing: Text(_fmt(c.start)),
            onTap: () {
              Navigator.pop(context);
              widget.playback.seek(c.start);
            },
          );
        },
      ),
    );
  }

  int _currentChapterIndex() {
    final np = widget.playback.nowPlaying;
    if (np == null || np.chapters.isEmpty) return -1;
    final pos = widget.playback.player.position;
    for (var i = 0; i < np.chapters.length; i++) {
      final start = np.chapters[i].start;
      final nextStart =
      (i + 1 < np.chapters.length) ? np.chapters[i + 1].start : null;
      if (nextStart == null) {
        if (pos >= start) return i;
      } else {
        if (pos >= start && pos < nextStart) return i;
      }
    }
    return -1;
  }

  void _prevChapter() {
    final np = widget.playback.nowPlaying;
    if (np == null || np.chapters.isEmpty) return;
    final idx = _currentChapterIndex();
    final target = (idx > 0) ? idx - 1 : 0;
    widget.playback.seek(np.chapters[target].start);
  }

  void _nextChapter() {
    final np = widget.playback.nowPlaying;
    if (np == null || np.chapters.isEmpty) return;
    final idx = _currentChapterIndex();
    final target =
    (idx >= 0 && idx + 1 < np.chapters.length) ? idx + 1 : np.chapters.length - 1;
    widget.playback.seek(np.chapters[target].start);
  }
}

class _SpeedSheet extends StatelessWidget {
  const _SpeedSheet({required this.current});
  final double current;

  @override
  Widget build(BuildContext context) {
    final options = [0.8, 1.0, 1.25, 1.5, 1.75, 2.0];
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          for (final v in options)
            RadioListTile<double>(
              value: v,
              groupValue: current,
              title: Text('${v.toStringAsFixed(2)}x'),
              onChanged: (nv) => Navigator.pop(context, nv),
            ),
          const SizedBox(height: 8),
        ],
      ),
    );
  }
}

class _SleepSheet extends StatelessWidget {
  const _SleepSheet();

  @override
  Widget build(BuildContext context) {
    final options = const [
      Duration(minutes: 15),
      Duration(minutes: 30),
      Duration(minutes: 45),
      Duration(hours: 1),
    ];
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          for (final d in options)
            ListTile(
              leading: const Icon(Icons.nightlight_round),
              title: Text('${d.inMinutes} minutes'),
              onTap: () => Navigator.pop(context, d),
            ),
          ListTile(
            leading: const Icon(Icons.cancel_outlined),
            title: const Text('Cancel timer'),
            onTap: () => Navigator.pop(context, null),
          ),
          const SizedBox(height: 8),
        ],
      ),
    );
  }
}

=== ./lib/ui/player/player_controller.dart ===
// lib/ui/player/player_controller.dart
import 'dart:async';

import '../../core/playback_repository.dart';

/// Very thin wrapper used by some UI code to start playback via the shared
/// app player (defined in core/playback_repository.dart).
class PlayerController {
  final PlaybackRepository playbackRepo;
  PlayerController(this.playbackRepo);

  /// Expose a simple seconds stream for legacy callers (derived from
  /// PlaybackRepository's position stream).
  Stream<double> get positionSecondsStream =>
      playbackRepo.positionStream.map((d) => d.inMilliseconds / 1000.0);

  /// Start playback of a library item (or specific episode) using the shared
  /// player managed by PlaybackRepository.
  Future<void> playItem(String libraryItemId, {String? episodeId}) {
    return playbackRepo.playItem(libraryItemId, episodeId: episodeId);
  }

  /// Pause/resume helpers, if needed by callers.
  Future<void> pause() => playbackRepo.pause();
  Future<void> resume() => playbackRepo.resume();

  /// Optional cleanup hook — the shared player lives in PlaybackRepository,
  /// so there is nothing to dispose here.
  Future<void> dispose() async {}
}

=== ./lib/ui/player/mini_player.dart ===
// Keep legacy imports working by re-exporting the real widget.
export '../../widgets/mini_player.dart';

=== ./lib/core/books_repository.dart ===
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/book.dart';
import 'auth_repository.dart';

class BooksRepository {
  BooksRepository(this._auth, this._prefs);
  final AuthRepository _auth;
  final SharedPreferences _prefs;

  static const _etagKey = 'books_list_etag';
  static const _cacheKey = 'books_list_cache_json';
  static const _libIdKey = 'books_library_id';

  Future<String> _ensureLibraryId() async {
    final cached = _prefs.getString(_libIdKey);
    if (cached != null && cached.isNotEmpty) return cached;

    final api = _auth.api;
    final token = await api.accessToken();
    final tokenQS = (token != null && token.isNotEmpty) ? '?token=$token' : '';
    final resp = await api.request('GET', '/api/libraries$tokenQS');

    if (resp.statusCode != 200) {
      throw Exception('Failed to list libraries: ${resp.statusCode}');
    }

    final bodyStr = resp.body;
    final body = bodyStr.isNotEmpty ? jsonDecode(bodyStr) : null;

    final libs = (body is Map && body['libraries'] is List)
        ? (body['libraries'] as List)
        : (body is List ? body : const []);

    if (libs.isEmpty) {
      throw Exception('No libraries accessible for this user');
    }

    Map<String, dynamic>? chosen;
    for (final l in libs) {
      final m = (l as Map).cast<String, dynamic>();
      final mt = (m['mediaType'] ?? m['type'] ?? '').toString().toLowerCase();
      if (mt.contains('book')) {
        chosen = m;
        break;
      }
    }
    chosen ??= (libs.first as Map).cast<String, dynamic>();

    final id = (chosen['id'] ?? chosen['_id'] ?? '').toString();
    if (id.isEmpty) throw Exception('Invalid library id from /api/libraries');

    await _prefs.setString(_libIdKey, id);
    return id;
  }

  List<Map<String, dynamic>> _extractItems(dynamic body) {
    if (body is Map) {
      // common shapes seen in the wild
      final keys = ['items', 'libraryItems', 'results', 'data'];
      for (final k in keys) {
        final v = body[k];
        if (v is List) {
          return v.cast<Map>().map((e) => e.cast<String, dynamic>()).toList();
        }
      }
    }
    if (body is List) {
      return body.cast<Map>().map((e) => e.cast<String, dynamic>()).toList();
    }
    return const [];
  }

  Future<List<Book>> listBooks() async {
    final api = _auth.api;
    final token = await api.accessToken();
    final libId = await _ensureLibraryId();

    // Auth via query (robust for GET on some deployments)
    final tokenQS = (token != null && token.isNotEmpty) ? '&token=$token' : '';
    final etag = _prefs.getString(_etagKey);
    final headers = <String, String>{};
    if (etag != null) headers['If-None-Match'] = etag;

    final path =
        '/api/libraries/$libId/items?limit=200&sort=updatedAt:desc$tokenQS';

    final http.Response resp = await api.request('GET', path, headers: headers);

    if (resp.statusCode == 304) {
      final cached = _prefs.getString(_cacheKey);
      if (cached != null) {
        final data = jsonDecode(cached);
        final items = _extractItems(data);
        return _toBooks(items);
      }
      return <Book>[];
    }

    if (resp.statusCode == 200) {
      final bodyStr = resp.body;
      final body = bodyStr.isNotEmpty ? jsonDecode(bodyStr) : null;

      final newEtag = resp.headers['etag'];
      await _prefs.setString(_cacheKey, bodyStr);
      if (newEtag != null) await _prefs.setString(_etagKey, newEtag);

      final items = _extractItems(body);
      if (items.isEmpty && bodyStr.isNotEmpty) {
        final preview = bodyStr.substring(0, bodyStr.length.clamp(0, 300));
        throw Exception('Library returned no parseable items. Body preview: $preview');
      }
      return _toBooks(items);
    }

    // Fallback to cache on errors
    final cached = _prefs.getString(_cacheKey);
    if (cached != null) {
      final data = jsonDecode(cached);
      final items = _extractItems(data);
      return _toBooks(items);
    }

    throw Exception('Failed to load books: ${resp.statusCode}');
  }

  Future<List<Book>> _toBooks(List<Map<String, dynamic>> items) async {
    final baseUrl = _auth.api.baseUrl ?? '';
    final token = await _auth.api.accessToken(); // nullable OK
    return items
        .map((e) => Book.fromLibraryItemJson(e, baseUrl: baseUrl, token: token))
        .where((b) => b.title.isNotEmpty)
        .toList();
  }

  Future<Book> getBook(String id) async {
    final api = _auth.api;
    final baseUrl = _auth.api.baseUrl ?? '';
    final token = await _auth.api.accessToken();
    final tokenQS = (token != null && token.isNotEmpty) ? '?token=$token' : '';

    final resp = await api.request('GET', '/api/items/$id$tokenQS');
    if (resp.statusCode != 200) {
      throw Exception('Failed to load book $id: ${resp.statusCode}');
    }

    final bodyStr = resp.body;
    final body = bodyStr.isNotEmpty ? jsonDecode(bodyStr) : null;
    final item = (body is Map && body['item'] is Map)
        ? (body['item'] as Map).cast<String, dynamic>()
        : (body as Map).cast<String, dynamic>();

    return Book.fromLibraryItemJson(item, baseUrl: baseUrl, token: token);
  }

  static Future<BooksRepository> create() async {
    final auth = await AuthRepository.ensure();
    final prefs = await SharedPreferences.getInstance();
    return BooksRepository(auth, prefs);
  }
}

=== ./lib/core/auth_repository.dart ===
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'api_client.dart';

/// AuthRepository
/// -------------------------
/// - Singleton: use `await AuthRepository.ensure()` at startup
/// - Persists/refreshes tokens via ApiClient
/// - Exposes simple `login`, `logout`, `hasValidSession`
class AuthRepository {
  AuthRepository._(this._prefs, this._secure) : _api = ApiClient(_prefs, _secure);

  final SharedPreferences _prefs;
  final FlutterSecureStorage _secure;
  late final ApiClient _api;

  static AuthRepository? _instanceInternal;

  /// Access the initialized singleton.
  /// Make sure to call `await AuthRepository.ensure()` first.
  static AuthRepository get instance {
    final inst = _instanceInternal;
    if (inst == null) {
      throw StateError('AuthRepository not initialized. Call AuthRepository.ensure() first.');
    }
    return inst;
  }

  /// Initialize (or return existing) singleton.
  static Future<AuthRepository> ensure() async {
    if (_instanceInternal != null) return _instanceInternal!;
    final prefs = await SharedPreferences.getInstance();
    const secure = FlutterSecureStorage();
    _instanceInternal = AuthRepository._(prefs, secure);
    return _instanceInternal!;
  }

  /// Returns true if we have a base URL + refresh token and a refresh succeeds.
  Future<bool> hasValidSession() async {
    if (_api.baseUrl == null) return false;
    // Use the *public* wrapper on ApiClient to avoid private access.
    final ok = await _api.refreshAccessToken();
    return ok;
  }

  Future<bool> login({
    required String baseUrl,
    required String username,
    required String password,
  }) {
    return _api.login(baseUrl: baseUrl, username: username, password: password);
  }

  Future<void> logout() => _api.logout();

  ApiClient get api => _api;
}

=== ./lib/core/theme_service.dart ===
// lib/core/theme_service.dart
import 'package:flutter/material.dart';

/// Minimal theme controller used by settings_page.dart via ServicesScope.
/// Access current mode with [mode.value], update with [set] or [toggle].
class ThemeService {
  final ValueNotifier<ThemeMode> mode = ValueNotifier<ThemeMode>(ThemeMode.system);

  void set(ThemeMode next) => mode.value = next;

  void toggle() {
    mode.value = (mode.value == ThemeMode.dark) ? ThemeMode.light : ThemeMode.dark;
  }
}

=== ./lib/core/player_gate.dart ===
// lib/core/player_gate.dart
import 'package:flutter/material.dart';

/// Ensures the full-screen player (or its bottom sheet) is opened at most once
/// at a time. Use this everywhere you navigate to the player UI to avoid
/// stacking two sheets/screens on top of each other.
class PlayerGate {
  static final PlayerGate I = PlayerGate._();
  PlayerGate._();

  bool _open = false;

  /// Open a full-screen route once (e.g., a dedicated NowPlayingPage).
  Future<void> openOnce(BuildContext context, Widget page) async {
    if (_open) return;
    _open = true;
    try {
      await Navigator.of(context).push(
        PageRouteBuilder(
          opaque: true,
          pageBuilder: (_, __, ___) => page,
        ),
      );
    } finally {
      _open = false;
    }
  }

  /// Open a modal bottom sheet once (e.g., your FullPlayerSheet).
  Future<void> openSheetOnce(
      BuildContext context,
      Widget Function() builder,
      ) async {
    if (_open) return;
    _open = true;
    try {
      await showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (_) => builder(),
      );
    } finally {
      _open = false;
    }
  }
}

=== ./lib/core/downloads_repository.dart ===
// lib/core/downloads_repository.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:background_downloader/background_downloader.dart';
import 'package:flutter/foundation.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'auth_repository.dart';
import 'playback_repository.dart';

class ItemProgress {
  final String libraryItemId;
  final String status; // queued | running | complete | canceled | failed | none
  final double progress; // 0..1
  final int totalTasks;
  final int completed;

  const ItemProgress({
    required this.libraryItemId,
    required this.status,
    required this.progress,
    required this.totalTasks,
    required this.completed,
  });
}

class DownloadsRepository {
  DownloadsRepository(this._auth, this._playback);
  final AuthRepository _auth;
  final PlaybackRepository _playback;

  static const _wifiOnlyKey = 'downloads_wifi_only';

  void _d(String m) => debugPrint('[DL] $m');

  // Plugin updates -> broadcast for UI
  Stream<TaskUpdate>? _broadcastUpdates;
  Stream<TaskUpdate> progressStream() {
    _broadcastUpdates ??= FileDownloader().updates.asBroadcastStream();
    return _broadcastUpdates!;
  }

  // Per-item aggregated progress streams
  final Map<String, StreamController<ItemProgress>> _itemCtrls = {};
  StreamSubscription<TaskUpdate>? _muxSub;

  Future<void> init() async {
    // Configure ONE global notification. Do NOT set per-task displayName.
    try {
      await FileDownloader().configureNotification(
        running: const TaskNotification('Downloading audiobooks…', ''),
        complete: const TaskNotification('Downloads complete', ''),
        error: const TaskNotification('Download failed', ''),
      );
    } catch (_) {}
  }

  /// Start (or get) an aggregated progress stream for a specific book.
  Stream<ItemProgress> watchItemProgress(String libraryItemId) {
    final ctrl = _itemCtrls.putIfAbsent(
      libraryItemId,
          () => StreamController<ItemProgress>.broadcast(onListen: () async {
        final snap = await _computeItemProgress(libraryItemId);
        (_itemCtrls[libraryItemId]!)..add(snap);
      }),
    );

    // Demux plugin updates -> per-item controllers
    _muxSub ??= progressStream().listen((u) async {
      final meta = u.task.metaData ?? '';
      final id = _extractItemId(meta);
      if (id == null) return;
      if (_itemCtrls.containsKey(id)) {
        final snap = await _computeItemProgress(id);
        final c = _itemCtrls[id];
        if (c != null && !c.isClosed) c.add(snap);
      }
    });

    return ctrl.stream;
  }

  /// Queue all tracks of an item for download (Wi-Fi rule from prefs).
  /// If the item already has local files AND no active tasks -> no-op (UI should show Delete).
  Future<void> enqueueItemDownloads(
      String libraryItemId, {
        String? episodeId,
      }) async {
    // If already downloaded and no tasks => nothing to enqueue
    if (await hasLocalDownloads(libraryItemId)) {
      final recs = await _recordsForItem(libraryItemId);
      if (recs.isEmpty) {
        _d('Already local for $libraryItemId; skipping enqueue.');
        _notifyItem(libraryItemId);
        return;
      }
    }

    final tracks =
    await _playback.getPlayableTracks(libraryItemId, episodeId: episodeId);

    final remoteTracks = tracks.where((t) => !t.isLocal).toList();
    if (remoteTracks.isEmpty) {
      _d('No remote tracks to download for $libraryItemId (already local?).');
      _notifyItem(libraryItemId);
      return;
    }

    final prefs = await SharedPreferences.getInstance();
    final wifiOnly = prefs.getBool(_wifiOnlyKey) ?? true;

    // Enqueue WITHOUT per-task displayName to keep a single system notification
    for (final t in remoteTracks) {
      final filename =
          'track_${t.index.toString().padLeft(3, '0')}.${_extFromMime(t.mimeType)}';

      final task = DownloadTask(
        url: t.url, // absolute URL with token
        filename: filename,
        directory: 'abs/$libraryItemId',
        baseDirectory: BaseDirectory.applicationDocuments,
        updates: Updates.statusAndProgress,
        requiresWiFi: wifiOnly,
        allowPause: true,
        metaData: jsonEncode({'libraryItemId': libraryItemId}),
      );

      await FileDownloader().enqueue(task);
    }

    _notifyItem(libraryItemId);
  }

  /// Cancel all queued/running tasks for a book.
  Future<void> cancelForItem(String libraryItemId) async {
    final recs = await _recordsForItem(libraryItemId);
    for (final r in recs) {
      await FileDownloader().cancelTaskWithId(r.taskId);
    }
    _notifyItem(libraryItemId);
  }

  /// Remove local files for a book (and cancel tasks just in case).
  Future<void> deleteLocal(String libraryItemId) async {
    await cancelForItem(libraryItemId);
    final dir = await _itemDir(libraryItemId);
    if (await dir.exists()) {
      await dir.delete(recursive: true);
    }
    _notifyItem(libraryItemId);
  }

  Future<void> cancelAll() async {
    final records = await FileDownloader().database.allRecords();
    final ids = records.map((r) => r.taskId).toList();
    if (ids.isNotEmpty) {
      await FileDownloader().cancelTasksWithIds(ids);
    }
  }

  Future<List<TaskRecord>> listAll() =>
      FileDownloader().database.allRecords();

  // === Local files helpers ===

  Future<bool> hasLocalDownloads(String libraryItemId) async {
    final dir = await _itemDir(libraryItemId);
    return dir.exists();
  }

  // === Internal aggregation ===

  Future<ItemProgress> _computeItemProgress(String libraryItemId) async {
    final recs = await _recordsForItem(libraryItemId);
    if (recs.isEmpty) {
      // If there are no tasks but local files exist, treat as complete
      final local = await hasLocalDownloads(libraryItemId);
      return ItemProgress(
        libraryItemId: libraryItemId,
        status: local ? 'complete' : 'none',
        progress: local ? 1.0 : 0.0,
        totalTasks: 0,
        completed: local ? 1 : 0,
      );
    }

    int total = recs.length;
    int done = recs.where((r) => r.status == TaskStatus.complete).length;

    double sum = 0.0;
    for (final r in recs) {
      if (r.status == TaskStatus.complete) {
        sum += 1.0;
      } else {
        sum += (r.progress ?? 0.0);
      }
    }
    final avg = sum / total;

    String status = 'running';
    if (done == total) status = 'complete';
    if (recs.any((r) => r.status == TaskStatus.failed)) status = 'failed';
    if (recs.every((r) => r.status == TaskStatus.enqueued)) status = 'queued';
    if (recs.every((r) => r.status == TaskStatus.canceled)) status = 'canceled';

    return ItemProgress(
      libraryItemId: libraryItemId,
      status: status,
      progress: avg,
      totalTasks: total,
      completed: done,
    );
  }

  Future<List<TaskRecord>> _recordsForItem(String libraryItemId) async {
    final all = await FileDownloader().database.allRecords();
    return all.where((r) {
      final meta = r.task.metaData ?? '';
      final id = _extractItemId(meta);
      return id == libraryItemId;
    }).toList();
  }

  String? _extractItemId(String meta) {
    try {
      final m = jsonDecode(meta);
      if (m is Map && m['libraryItemId'] is String) {
        return m['libraryItemId'] as String;
      }
    } catch (_) {}
    return null;
  }

  static String _extFromMime(String mime) {
    final m = mime.toLowerCase();
    if (m.contains('mpeg')) return 'mp3';
    if (m.contains('mp4') || m.contains('aac')) return 'm4a';
    if (m.contains('flac')) return 'flac';
    return 'bin';
  }

  Future<Directory> _itemDir(String libraryItemId) async {
    final docs = await getApplicationDocumentsDirectory();
    return Directory('${docs.path}/abs/$libraryItemId');
  }

  void _notifyItem(String libraryItemId) async {
    final c = _itemCtrls[libraryItemId];
    if (c != null && !c.isClosed) {
      c.add(await _computeItemProgress(libraryItemId));
    }
  }
}

=== ./lib/core/playback_repository.dart ===
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:audio_session/audio_session.dart';
import 'package:flutter/widgets.dart';
import 'package:http/http.dart' as http;
import 'package:just_audio/just_audio.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'auth_repository.dart';

const _kProgressPing = Duration(seconds: 15);
const _kLocalProgPrefix = 'abs_progress:';      // local fallback per item
const _kLastItemKey = 'abs_last_item_id';       // last played item id

class PlaybackTrack {
  final int index;
  final String url;
  final String mimeType;
  final double duration; // seconds (0 if unknown)
  final bool isLocal;
  PlaybackTrack({
    required this.index,
    required this.url,
    required this.mimeType,
    required this.duration,
    this.isLocal = false,
  });

  PlaybackTrack copyWith({double? duration}) => PlaybackTrack(
    index: index,
    url: url,
    mimeType: mimeType,
    duration: duration ?? this.duration,
    isLocal: isLocal,
  );
}

class Chapter {
  final String title;
  final Duration start;
  Chapter({required this.title, required this.start});
}

class NowPlaying {
  final String libraryItemId;
  final String title;
  final String? author;
  final String? coverUrl;
  final List<PlaybackTrack> tracks;
  final int currentIndex;
  final List<Chapter> chapters;
  final String? episodeId;

  const NowPlaying({
    required this.libraryItemId,
    required this.title,
    required this.tracks,
    required this.currentIndex,
    required this.chapters,
    this.author,
    this.coverUrl,
    this.episodeId,
  });

  NowPlaying copyWith({int? currentIndex, List<PlaybackTrack>? tracks}) =>
      NowPlaying(
        libraryItemId: libraryItemId,
        title: title,
        author: author,
        coverUrl: coverUrl,
        tracks: tracks ?? this.tracks,
        currentIndex: currentIndex ?? this.currentIndex,
        chapters: chapters,
        episodeId: episodeId,
      );
}

class PlaybackRepository {
  final StreamController<String> _debugLogCtr = StreamController.broadcast();
  Stream<String> get debugLogStream => _debugLogCtr.stream;

  void _log(String msg) {
    debugPrint("[ABS] $msg");
    _debugLogCtr.add(msg);
  }

  PlaybackRepository(this._auth) {
    _init();
  }

  final AuthRepository _auth;
  final AudioPlayer player = AudioPlayer();

  final StreamController<NowPlaying?> _nowPlayingCtr =
  StreamController.broadcast();
  NowPlaying? _nowPlaying;
  Stream<NowPlaying?> get nowPlayingStream => _nowPlayingCtr.stream;
  NowPlaying? get nowPlaying => _nowPlaying;

  Stream<bool> get playingStream => player.playingStream;
  Stream<Duration> get positionStream => player.createPositionStream();
  Stream<Duration?> get durationStream => player.durationStream;
  Stream<PlayerState> get playerStateStream => player.playerStateStream;
  Stream<ProcessingState> get processingStateStream =>
      player.processingStateStream;

  String? _progressItemId;

  late final WidgetsBindingObserver _lifecycleHook = _LifecycleHook(
    onPauseOrDetach: () => _sendProgressImmediate(),
  );

  Future<List<PlaybackTrack>> getPlayableTracks(String libraryItemId,
      {String? episodeId}) =>
      _getTracksPreferLocal(libraryItemId, episodeId: episodeId);

  /// Warm-load last item (server position wins). If [playAfterLoad] true, will start playback.
  Future<void> warmLoadLastItem({bool playAfterLoad = false}) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final last = prefs.getString(_kLastItemKey);
      if (last == null || last.isEmpty) return;

      final meta = await _getItemMeta(last);
      final chapters = _extractChapters(meta);
      final tracks = await _getTracksPreferLocal(last);
      final tracksWithDur = await _ensureDurations(tracks, last);

      final np = NowPlaying(
        libraryItemId: last,
        title: _titleFromMeta(meta) ?? 'Audiobook',
        author: _authorFromMeta(meta),
        coverUrl: await _coverUrl(last),
        tracks: tracksWithDur,
        currentIndex: 0,
        chapters: chapters,
      );
      _setNowPlaying(np);
      _progressItemId = last;

      final resumeSec = await fetchServerProgress(last) ??
          prefs.getDouble('$_kLocalProgPrefix$last');

      // Map to track and seek BEFORE starting
      if (resumeSec != null && resumeSec > 0) {
        final map = _mapGlobalSecondsToTrack(resumeSec, np.tracks);
        await _setTrackAt(map.index, preload: true);
        await player.seek(Duration(milliseconds: (map.offsetSec * 1000).round()));
      } else {
        await _setTrackAt(0, preload: true);
      }

      if (playAfterLoad) {
        await player.play();
        await _sendProgressImmediate();
      }
    } catch (e) {
      _log('warmLoadLastItem error: $e');
    }
  }

  Future<double?> fetchServerProgress(String libraryItemId) async {
    final api = _auth.api;
    final resp = await api.request('GET', '/api/me/progress/$libraryItemId');
    if (resp.statusCode != 200) return null;
    try {
      final data = jsonDecode(resp.body);
      if (data is Map<String, dynamic>) {
        if (data['currentTime'] is num) return (data['currentTime'] as num).toDouble();
        if (data['currentTime'] is String) return double.tryParse(data['currentTime'] as String);
        final first = _firstMapValue(data);
        if (first != null) {
          final v = first['currentTime'];
          if (v is num) return v.toDouble();
          if (v is String) return double.tryParse(v);
        }
      }
    } catch (_) {}
    return null;
  }

  Future<void> playItem(String libraryItemId, {String? episodeId}) async {
    final session = await AudioSession.instance;
    await session.configure(const AudioSessionConfiguration.music());

    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_kLastItemKey, libraryItemId);

    final meta = await _getItemMeta(libraryItemId);
    final chapters = _extractChapters(meta);

    var tracks = await _getTracksPreferLocal(libraryItemId, episodeId: episodeId);
    tracks = await _ensureDurations(tracks, libraryItemId, episodeId: episodeId);

    final np = NowPlaying(
      libraryItemId: libraryItemId,
      title: _titleFromMeta(meta) ?? 'Audiobook',
      author: _authorFromMeta(meta),
      coverUrl: await _coverUrl(libraryItemId),
      tracks: tracks,
      currentIndex: 0,
      chapters: chapters,
      episodeId: episodeId,
    );
    _setNowPlaying(np);
    _progressItemId = libraryItemId;

    // SERVER WINS: try server position first; fallback to local cache
    double? resumeSec = await fetchServerProgress(libraryItemId);
    resumeSec ??= prefs.getDouble('$_kLocalProgPrefix$libraryItemId');

    if (resumeSec != null && resumeSec > 0) {
      final map = _mapGlobalSecondsToTrack(resumeSec, tracks);
      await _setTrackAt(map.index, preload: true);
      await player.seek(Duration(milliseconds: (map.offsetSec * 1000).round()));
    } else {
      await _setTrackAt(0, preload: true);
    }

    _startProgressSync(libraryItemId, episodeId: episodeId);

    player.processingStateStream.listen((state) async {
      if (state == ProcessingState.completed) {
        final cur = _nowPlaying;
        if (cur == null) return;
        final next = cur.currentIndex + 1;
        if (next < cur.tracks.length) {
          await _setTrackAt(next, preload: true);
          await player.play();
          await _sendProgressImmediate();
        }
      }
    });

    await player.play();
    await _sendProgressImmediate();
  }

  Future<void> pause() async {
    await player.pause();
    await _sendProgressImmediate();
  }

  Future<void> resume() async {
    await player.play();
    await _sendProgressImmediate();
  }

  /// When scrubbing, pass `reportNow: false` repeatedly; only call once with true at the end.
  Future<void> seek(Duration pos, {bool reportNow = true}) async {
    await player.seek(pos);
    if (reportNow) {
      await _sendProgressImmediate(
        overrideTrackPosSec: pos.inMilliseconds / 1000.0,
      );
    }
  }

  Future<void> nudgeSeconds(int delta) async {
    final total = player.duration ?? Duration.zero;
    var target = player.position + Duration(seconds: delta);
    if (target < Duration.zero) target = Duration.zero;
    if (target > total) target = total;
    await seek(target, reportNow: true);
  }

  Future<void> reportProgressNow() => _sendProgressImmediate();

  Future<void> setSpeed(double speed) => player.setSpeed(speed.clamp(0.5, 3.0));
  bool get hasPrev => _nowPlaying != null && _nowPlaying!.currentIndex > 0;
  bool get hasNext =>
      _nowPlaying != null &&
          _nowPlaying!.currentIndex + 1 < _nowPlaying!.tracks.length;

  Future<void> prevTrack() async {
    if (!hasPrev) return;
    final idx = _nowPlaying!.currentIndex - 1;
    await _setTrackAt(idx, preload: true);
    await player.play();
    await _sendProgressImmediate();
  }

  Future<void> nextTrack() async {
    if (!hasNext) return;
    final idx = _nowPlaying!.currentIndex + 1;
    await _setTrackAt(idx, preload: true);
    await player.play();
    await _sendProgressImmediate();
  }

  Future<void> stop() async {
    await player.stop();
    await _sendProgressImmediate(finished: true);
    _stopProgressSync();
    _setNowPlaying(null);
    _progressItemId = null;
  }

  // ---- Progress sync ----

  Timer? _progressTimer;
  double _lastSentSec = -1;

  void _startProgressSync(String libraryItemId, {String? episodeId}) {
    _progressTimer?.cancel();

    _progressTimer = Timer.periodic(_kProgressPing, (_) {
      _sendProgressImmediate();
    });

    player.positionStream.listen((_) {
      final cur = _computeGlobalPositionSec() ?? _trackOnlyPosSec();
      final total = _computeTotalDurationSec();
      if (cur == null) return;

      final bigJump = (_lastSentSec - cur).abs() >= 30;
      final isDone = (total != null && total > 0) ? (cur / total) >= 0.999 : false;
      if (bigJump || isDone) {
        _sendProgressImmediate(finished: isDone);
      }
    });
  }

  void _stopProgressSync() {
    _progressTimer?.cancel();
    _progressTimer = null;
  }

  /// Always try to send at least `currentTime`. Include `duration/progress`
  /// only when we know the total.
  Future<void> _sendProgressImmediate({
    double? overrideTrackPosSec,
    bool finished = false,
  }) async {
    final itemId = _progressItemId;
    final np = _nowPlaying;
    if (itemId == null || np == null) return;

    final total = _computeTotalDurationSec();
    final cur = (overrideTrackPosSec != null)
        ? _computeGlobalFromTrackPos(overrideTrackPosSec)
        : (_computeGlobalPositionSec() ?? _trackOnlyPosSec());

    if (cur == null) return;

    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble('$_kLocalProgPrefix$itemId', cur);
    } catch (_) {}

    _lastSentSec = cur;

    final api = _auth.api;
    final path = (np.episodeId == null)
        ? '/api/me/progress/$itemId'
        : '/api/me/progress/$itemId/${np.episodeId}';

    final bodyMap = <String, dynamic>{
      'currentTime': cur,
      'isFinished': finished,
    };
    if (total != null && total > 0) {
      bodyMap['duration'] = total;
      bodyMap['progress'] = (cur / total).clamp(0.0, 1.0);
    }

    http.Response? resp;
    _log("Sending progress: cur=$cur, total=$total, finished=$finished");

    try {
      resp = await api.request('PATCH', path,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(bodyMap));
      _log("PATCH ${resp.statusCode} ${resp.body}");
      if (resp.statusCode == 200 || resp.statusCode == 204) return;
    } catch (e) {
      _log("PATCH error: $e");
    }

    // Fallbacks
    try {
      resp = await api.request('PUT', path,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(bodyMap));
      _log("PUT ${resp.statusCode} ${resp.body}");
      if (resp.statusCode == 200 || resp.statusCode == 204) return;
    } catch (e) {
      _log("PUT error: $e");
    }

    try {
      resp = await api.request('POST', path,
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode(bodyMap));
      _log("POST ${resp.statusCode} ${resp.body}");
    } catch (e) {
      _log("POST error: $e");
    }
  }

  // ---- Internals ----

  Future<void> _init() async {
    final session = await AudioSession.instance;
    await session.configure(const AudioSessionConfiguration.music());
    WidgetsBinding.instance.addObserver(_lifecycleHook);
  }

  Future<void> _setTrackAt(int index, {bool preload = false}) async {
    final cur = _nowPlaying!;
    final track = cur.tracks[index];

    if (track.isLocal) {
      await player.setFilePath(track.url, preload: preload);
    } else {
      await player.setUrl(track.url, preload: preload);
    }
    _setNowPlaying(cur.copyWith(currentIndex: index));
  }

  Future<List<PlaybackTrack>> _getTracksPreferLocal(String libraryItemId,
      {String? episodeId}) async {
    final local = await _localTracks(libraryItemId);
    if (local.isNotEmpty) return local;
    return _streamTracks(libraryItemId, episodeId: episodeId);
  }

  Future<List<PlaybackTrack>> _ensureDurations(
      List<PlaybackTrack> tracks, String libraryItemId,
      {String? episodeId}) async {
    final missing = tracks.any((t) => t.duration <= 0);
    if (!missing) return tracks;

    try {
      final remote = await _streamTracks(libraryItemId, episodeId: episodeId);
      final byIndex = {for (final t in remote) t.index: t.duration};
      return tracks
          .map((t) => t.duration > 0
          ? t
          : t.copyWith(duration: (byIndex[t.index] ?? 0.0)))
          .toList();
    } catch (_) {
      return tracks;
    }
  }

  Future<List<PlaybackTrack>> _streamTracks(String libraryItemId,
      {String? episodeId}) async {
    final api = _auth.api;
    final token = await api.accessToken();
    final baseStr = api.baseUrl ?? '';
    final base = Uri.parse(baseStr);

    final path = episodeId == null
        ? '/api/items/$libraryItemId/play'
        : '/api/items/$libraryItemId/play/$episodeId';

    final resp = await api.request('POST', path,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'deviceInfo': {'clientVersion': 'kitzi-android-0.1.0'},
          'supportedMimeTypes': ['audio/mpeg', 'audio/mp4', 'audio/aac', 'audio/flac']
        }));

    if (resp.statusCode != 200) {
      throw Exception('Failed to get tracks: ${resp.statusCode}');
    }

    final data = jsonDecode(resp.body) as Map<String, dynamic>;
    final tracks = (data['audioTracks'] as List?) ?? const [];
    return tracks.map((t) {
      final m = (t as Map).cast<String, dynamic>();
      final idx = (m['index'] as num?)?.toInt() ?? 0;
      final dur = (m['duration'] as num?)?.toDouble() ?? 0.0; // seconds
      final mime = (m['mimeType'] ?? 'audio/mpeg').toString();
      final contentUrl = (m['contentUrl'] ?? '').toString();

      Uri abs = Uri.tryParse(contentUrl) ?? Uri(path: contentUrl);
      if (!abs.hasScheme) {
        final rel = contentUrl.startsWith('/') ? contentUrl.substring(1) : contentUrl;
        abs = base.resolve(rel);
      }
      if (token != null && token.isNotEmpty) {
        abs = abs.replace(queryParameters: {
          ...abs.queryParameters,
          'token': token,
        });
      }

      return PlaybackTrack(
        index: idx,
        url: abs.toString(),
        mimeType: mime,
        duration: dur,
        isLocal: false,
      );
    }).toList()
      ..sort((a, b) => a.index.compareTo(b.index));
  }

  Future<List<PlaybackTrack>> _localTracks(String libraryItemId) async {
    try {
      final docs = await getApplicationDocumentsDirectory();
      final dir = Directory('${docs.path}/abs/$libraryItemId');
      if (!await dir.exists()) return const [];
      final files = (await dir.list().toList()).whereType<File>().toList()
        ..sort((a, b) => a.path.compareTo(b.path));
      if (files.isEmpty) return const [];
      final list = <PlaybackTrack>[];
      for (var i = 0; i < files.length; i++) {
        final f = files[i];
        final ext = f.path.split('.').last.toLowerCase();
        final mime = ext == 'mp3'
            ? 'audio/mpeg'
            : (ext == 'm4a' || ext == 'aac')
            ? 'audio/mp4'
            : ext == 'flac'
            ? 'audio/flac'
            : 'audio/mpeg';
        list.add(PlaybackTrack(
          index: i,
          url: f.path,
          mimeType: mime,
          duration: 0.0, // unknown until merged
          isLocal: true,
        ));
      }
      return list;
    } catch (_) {
      return const [];
    }
  }

  Future<Map<String, dynamic>> _getItemMeta(String libraryItemId) async {
    final baseStr = _auth.api.baseUrl ?? '';
    final base = Uri.parse(baseStr);
    final token = await _auth.api.accessToken();

    Uri meta = base.resolve('api/items/$libraryItemId');
    if (token != null && token.isNotEmpty) {
      meta = meta.replace(queryParameters: {
        ...meta.queryParameters,
        'token': token,
      });
    }

    final r = await http.get(meta);
    try {
      final j = jsonDecode(r.body) as Map<String, dynamic>;
      return (j['item'] as Map?)?.cast<String, dynamic>() ?? j.cast<String, dynamic>();
    } catch (_) {
      return <String, dynamic>{};
    }
  }

  Future<String?> _coverUrl(String libraryItemId) async {
    final baseStr = _auth.api.baseUrl ?? '';
    final base = Uri.parse(baseStr);
    final token = await _auth.api.accessToken();

    Uri cov = base.resolve('api/items/$libraryItemId/cover');
    if (token != null && token.isNotEmpty) {
      cov = cov.replace(queryParameters: {
        ...cov.queryParameters,
        'token': token,
      });
    }
    return cov.toString();
  }

  void _setNowPlaying(NowPlaying? np) {
    _nowPlaying = np;
    _nowPlayingCtr.add(np);
  }

  // ----- Mapping / helpers -----

  double? _computeTotalDurationSec() {
    final tracks = _nowPlaying?.tracks ?? const <PlaybackTrack>[];
    double sum = 0.0;
    for (final t in tracks) {
      if (t.duration <= 0) {
        return null;
      }
      sum += t.duration;
    }
    return sum > 0 ? sum : null;
  }

  // track-only pos in seconds (fallback when global mapping impossible)
  double? _trackOnlyPosSec() => player.position.inMilliseconds / 1000.0;

  double? _computeGlobalPositionSec() {
    final np = _nowPlaying;
    if (np == null) return null;
    final idx = np.currentIndex;
    final pos = player.position.inMilliseconds / 1000.0;
    double prefix = 0.0;
    for (int i = 0; i < idx; i++) {
      final d = np.tracks[i].duration;
      if (d <= 0) return null;
      prefix += d;
    }
    return prefix + pos;
  }

  double _computeGlobalFromTrackPos(double trackPosSec) {
    final np = _nowPlaying!;
    final idx = np.currentIndex;
    double prefix = 0.0;
    for (int i = 0; i < idx; i++) {
      prefix += (np.tracks[i].duration > 0 ? np.tracks[i].duration : 0.0);
    }
    return prefix + trackPosSec;
  }

  _TrackMap _mapGlobalSecondsToTrack(double sec, List<PlaybackTrack> tracks) {
    double remain = sec;
    for (int i = 0; i < tracks.length; i++) {
      final d = tracks[i].duration;
      if (d <= 0) {
        return _TrackMap(index: i, offsetSec: remain);
      }
      if (remain < d) {
        return _TrackMap(index: i, offsetSec: remain);
      }
      remain -= d;
    }
    final last = tracks.isNotEmpty ? tracks.length - 1 : 0;
    return _TrackMap(index: last, offsetSec: tracks.isNotEmpty ? tracks[last].duration : 0.0);
  }

  String? _titleFromMeta(Map<String, dynamic> meta) {
    return (meta['title'] as String?) ??
        (meta['media']?['metadata']?['title'] as String?) ??
        (meta['book']?['title'] as String?);
  }

  String? _authorFromMeta(Map<String, dynamic> meta) {
    final a = (meta['author'] as String?) ??
        (meta['media']?['metadata']?['author'] as String?);
    if (a != null) return a;
    final authors = meta['authors'];
    if (authors is List && authors.isNotEmpty) {
      final first = authors.first;
      if (first is Map && first['name'] is String) return first['name'] as String;
      if (first is String) return first;
    }
    return null;
  }

  List<Chapter> _extractChapters(Map<String, dynamic> meta) {
    final chapters = <Chapter>[];
    final toc = meta['chapters'] ?? meta['tableOfContents'];
    if (toc is List) {
      for (final c in toc) {
        if (c is Map) {
          final title = (c['title'] ?? c['name'] ?? '').toString();
          final startMs = (c['start'] is num)
              ? (c['start'] as num).toDouble() * 1000
              : (c['startMs'] as num?)?.toDouble();
          if (startMs != null) {
            chapters.add(Chapter(title: title, start: Duration(milliseconds: startMs.round())));
          }
        }
      }
    }
    return chapters;
  }

  Map<String, dynamic>? _firstMapValue(Map<String, dynamic> m) {
    for (final v in m.values) {
      if (v is Map) {
        try {
          return v.cast<String, dynamic>();
        } catch (_) {}
      }
    }
    return null;
  }
}

class _LifecycleHook extends WidgetsBindingObserver {
  final Future<void> Function() onPauseOrDetach;
  _LifecycleHook({required this.onPauseOrDetach});

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.inactive ||
        state == AppLifecycleState.paused ||
        state == AppLifecycleState.detached) {
      onPauseOrDetach();
    }
  }
}

class _TrackMap {
  final int index;
  final double offsetSec;
  _TrackMap({required this.index, required this.offsetSec});
}



=== ./lib/core/api_client.dart ===
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ApiClient {
  ApiClient(this._prefs, this._secure);

  final SharedPreferences _prefs;
  final FlutterSecureStorage _secure;

  String? get baseUrl => _prefs.getString('abs_base_url');

  Future<void> setBaseUrl(String url) async {
    url = url.trim();
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://$url';
    }
    url = url.replaceAll(RegExp(r'/+$'), '');
    await _prefs.setString('abs_base_url', url);
  }

  // === Access/Refresh storage ===
  Future<String?> _getAccessToken() async => _prefs.getString('abs_access');
  Future<void> _setAccessToken(String token, DateTime expiry) async {
    await _prefs.setString('abs_access', token);
    await _prefs.setString('abs_access_exp', expiry.toIso8601String());
  }
  DateTime? _getAccessExpiry() {
    final s = _prefs.getString('abs_access_exp');
    return s != null ? DateTime.tryParse(s) : null;
  }
  Future<String?> _getRefreshToken() => _secure.read(key: 'abs_refresh');
  Future<void> _setRefreshToken(String token) =>
      _secure.write(key: 'abs_refresh', value: token);

  /// Public helper: get current access token (nullable).
  Future<String?> accessToken() => _getAccessToken();

  Future<void> clearTokens() async {
    await _prefs.remove('abs_access');
    await _prefs.remove('abs_access_exp');
    await _secure.delete(key: 'abs_refresh');
  }

  // === Requests with auto-refresh ===
  Future<http.Response> request(
      String method,
      String path, {
        Map<String, String>? headers,
        Object? body,
        bool auth = true,
      }) async {
    final base = baseUrl;
    if (base == null) throw Exception('Base URL not set');
    if (auth) {
      await _ensureAccessValid();
    }

    final uri = Uri.parse('$base$path');
    final reqHeaders = <String, String>{
      'Content-Type': 'application/json',
      ...?headers,
    };

    if (auth) {
      final access = await _getAccessToken();
      if (access != null) reqHeaders['Authorization'] = 'Bearer $access';
    }

    Future<http.Response> _send(String m) async {
      switch (m) {
        case 'GET':
          return http.get(uri, headers: reqHeaders);
        case 'POST':
          return http.post(uri, headers: reqHeaders, body: body as String?);
        case 'DELETE':
          return http.delete(uri, headers: reqHeaders, body: body as String?);
        case 'PUT':
          return http.put(uri, headers: reqHeaders, body: body as String?);
        case 'PATCH':
          return http.patch(uri, headers: reqHeaders, body: body as String?);
        default:
          throw UnimplementedError(m);
      }
    }

    var upper = method.toUpperCase();
    var resp = await _send(upper);

    if (auth && resp.statusCode == 401) {
      final refreshed = await _refreshAccessToken();
      if (refreshed) {
        final retryHeaders = Map<String, String>.from(reqHeaders);
        retryHeaders['Authorization'] = 'Bearer ${await _getAccessToken()}';
        resp = await _send(upper);
      }
    }
    return resp;
  }

  Future<void> _ensureAccessValid() async {
    final exp = _getAccessExpiry();
    if (exp == null) return;
    final now = DateTime.now().toUtc();
    if (exp.isBefore(now.add(const Duration(seconds: 60)))) {
      await _refreshAccessToken();
    }
  }

  Future<bool> _refreshAccessToken() async {
    final base = baseUrl;
    final refresh = await _getRefreshToken();
    if (base == null || refresh == null) return false;

    final resp = await http.post(
      Uri.parse('$base/auth/refresh'),
      headers: {
        'Content-Type': 'application/json',
        'x-refresh-token': refresh,
      },
    );
    if (resp.statusCode != 200) return false;

    final data = jsonDecode(resp.body);
    final user = data['user'] as Map<String, dynamic>?;
    final access = user?['accessToken'] as String?;
    final newRefresh = user?['refreshToken'] as String?;
    if (access == null) return false;

    final assumedExpiry = DateTime.now().toUtc().add(const Duration(hours: 12));
    await _setAccessToken(access, assumedExpiry);
    if (newRefresh != null && newRefresh.isNotEmpty) {
      await _setRefreshToken(newRefresh);
    }
    return true;
  }

  Future<bool> refreshAccessToken() => _refreshAccessToken();

  Future<bool> login({
    required String baseUrl,
    required String username,
    required String password,
  }) async {
    await setBaseUrl(baseUrl);
    final resp = await http.post(
      Uri.parse('$baseUrl/login'),
      headers: {
        'Content-Type': 'application/json',
        'x-return-tokens': 'true',
      },
      body: jsonEncode({'username': username, 'password': password}),
    );

    if (resp.statusCode != 200) return false;

    final data = jsonDecode(resp.body) as Map<String, dynamic>;
    final user = data['user'] as Map<String, dynamic>?;
    final access = user?['accessToken'] as String?;
    final refresh = user?['refreshToken'] as String?;
    if (access == null || refresh == null) return false;

    final assumedExpiry = DateTime.now().toUtc().add(const Duration(hours: 12));
    await _setAccessToken(access, assumedExpiry);
    await _setRefreshToken(refresh);
    return true;
  }

  Future<void> logout() async {
    final base = baseUrl;
    final refresh = await _getRefreshToken();
    try {
      if (base != null && refresh != null) {
        await http.post(
          Uri.parse('$base/logout'),
          headers: {
            'Content-Type': 'application/json',
            'x-refresh-token': refresh,
          },
        );
      }
    } finally {
      await clearTokens();
    }
  }
}

=== ./lib/core/url_utils.dart ===
// lib/core/url_utils.dart
import 'package:flutter/foundation.dart';

String normalizeBase(String input) {
  var url = input.trim();
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    url = 'https://$url';
  }
  // drop trailing slashes
  url = url.replaceAll(RegExp(r'/+$'), '');
  return url;
}

/// Builds a valid ABS URL from a base + (possibly absolute) contentUrl,
/// adding/merging the token as a query param safely.
String buildAbsUrl({
  required String baseUrl,
  required String contentUrl,
  String? token,
}) {
  final base = Uri.parse(normalizeBase(baseUrl));

  // If contentUrl is already absolute, start from it; else resolve against base.
  Uri u;
  final raw = contentUrl.trim();
  if (raw.isEmpty) {
    throw ArgumentError('Empty contentUrl');
  }
  final parsedContent = Uri.tryParse(raw);
  if (parsedContent == null) {
    throw ArgumentError('Unparseable contentUrl: $raw');
  }
  if (parsedContent.hasScheme) {
    u = parsedContent;
  } else {
    // Ensure leading slash so resolve() doesn’t drop path segments unexpectedly
    final rel = raw.startsWith('/') ? raw : '/$raw';
    u = base.resolve(rel);
  }

  // Merge token with existing query parameters (no double ??, no spaces)
  final qp = Map<String, String>.from(u.queryParameters);
  if (token != null && token.isNotEmpty) {
    qp['token'] = token;
  }

  // Rebuild with properly encoded path & query
  u = u.replace(queryParameters: qp);

  // Quick sanity checks (fail fast in debug)
  assert(u.hasScheme && u.hasAuthority);
  assert(!u.toString().contains(' '), 'URL contains spaces');

  return u.toString();
}

=== ./lib/models/book.dart ===
class Book {
  final String id;
  final String title;
  final String? author;
  final String coverUrl; // always a usable URL
  final String? description;
  final int? durationMs;
  final int? sizeBytes;
  final DateTime? updatedAt;

  Book({
    required this.id,
    required this.title,
    required this.coverUrl,
    this.author,
    this.description,
    this.durationMs,
    this.sizeBytes,
    this.updatedAt,
  });

  /// Build from ABS library item JSON (id + media.metadata.*).
  factory Book.fromLibraryItemJson(
      Map<String, dynamic> j, {
        required String baseUrl,
        String? token, // <-- nullable now
      }) {
    final id = (j['id'] ?? j['_id'] ?? '').toString();

    final media = j['media'] as Map<String, dynamic>? ?? const {};
    final meta = media['metadata'] as Map<String, dynamic>? ?? const {};
    final title = (j['title'] ?? meta['title'] ?? '').toString();
    final author =
    (j['author'] ?? meta['authorName'] ?? meta['author'] ?? meta['authors']?.toString());

    // Construct cover URL, add ?token= only if provided
    var coverUrl = '$baseUrl/api/items/$id/cover';
    if (token != null && token.isNotEmpty) {
      coverUrl = '$coverUrl?token=$token';
    }

    final description = (meta['description'] ?? j['description'])?.toString();
    final durationSecs = media['duration'] is num ? (media['duration'] as num).toDouble() : null;
    final updatedEpoch = j['updatedAt'] is num ? j['updatedAt'] as num : null;
    final sizeBytes = media['size'] is num ? (media['size'] as num).toInt() : null;

    return Book(
      id: id,
      title: title,
      author: author,
      coverUrl: coverUrl,
      description: description,
      durationMs: durationSecs != null ? (durationSecs * 1000).round() : null,
      sizeBytes: sizeBytes,
      updatedAt: updatedEpoch != null
          ? DateTime.fromMillisecondsSinceEpoch(updatedEpoch.toInt(), isUtc: true)
          : null,
    );
  }
}

=== ./lib/main.dart ===
import 'package:flutter/material.dart';

import 'core/auth_repository.dart';
import 'core/downloads_repository.dart';
import 'core/playback_repository.dart';
import 'core/theme_service.dart';

import 'ui/auth/auth_gate.dart';
import 'ui/auth/login_page.dart';
import 'ui/main/main_scaffold.dart';
import 'ui/player/full_player_page.dart';
import 'ui/settings/settings_page.dart'; // your existing page that referenced services.theme

/// Simple services bucket accessible via InheritedWidget.
class AppServices {
  AppServices({
    required this.auth,
    required this.playback,
    required this.downloads,
    required this.theme,
  });

  final AuthRepository auth;
  final PlaybackRepository playback;
  final DownloadsRepository downloads;
  final ThemeService theme; // ✅ provides `services.theme` for settings_page.dart
}

class ServicesScope extends InheritedWidget {
  const ServicesScope({
    super.key,
    required this.services,
    required super.child,
  });

  final AppServices services;

  static ServicesScope of(BuildContext context) {
    final res = context.dependOnInheritedWidgetOfExactType<ServicesScope>();
    assert(res != null, 'ServicesScope not found in context');
    return res!;
  }

  @override
  bool updateShouldNotify(covariant ServicesScope oldWidget) =>
      oldWidget.services != services;
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // ✅ Your project doesn’t have AuthRepository.create(); use default ctor
  final auth = AuthRepository();
  final playback = PlaybackRepository(auth);
  final downloads = DownloadsRepository(auth, playback);
  final theme = ThemeService();
  await downloads.init();

  runApp(MyApp(
    services: AppServices(
      auth: auth,
      playback: playback,
      downloads: downloads,
      theme: theme,
    ),
  ));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key, required this.services});
  final AppServices services;

  @override
  Widget build(BuildContext context) {
    // React to theme changes from settings
    return ServicesScope(
      services: services,
      child: ValueListenableBuilder<ThemeMode>(
        valueListenable: services.theme.mode,
        builder: (_, mode, __) {
          return MaterialApp(
            title: 'Kitzi',
            theme: ThemeData(
              useMaterial3: true,
              colorSchemeSeed: Colors.deepPurple,
              brightness: Brightness.light,
            ),
            darkTheme: ThemeData(
              useMaterial3: true,
              colorSchemeSeed: Colors.deepPurple,
              brightness: Brightness.dark,
            ),
            themeMode: mode, // ✅ driven by ThemeService
            routes: {
              '/login': (_) => const LoginPage(),
              '/player': (_) => const FullPlayerPage(),
              '/settings': (_) => const SettingsPage(), // ✅ make sure this exists
            },
            // Wrap your real shell with the auth gate
            home: AuthGate(
              // Your MainScaffold requires downloadsRepo
              child: MainScaffold(downloadsRepo: services.downloads),
            ),
          );
        },
      ),
    );
  }
}

=== ./lib/widgets/download_button.dart ===
// lib/widgets/download_button.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:background_downloader/background_downloader.dart';

import '../core/downloads_repository.dart';
import '../main.dart';

/// Button that adapts between Download / Cancel / Delete
/// and shows inline progress when running.
class DownloadButton extends StatefulWidget {
  const DownloadButton({super.key, required this.libraryItemId, this.titleForNotification});

  final String libraryItemId;
  final String? titleForNotification;

  @override
  State<DownloadButton> createState() => _DownloadButtonState();
}

class _DownloadButtonState extends State<DownloadButton> {
  late final DownloadsRepository _dl;
  StreamSubscription<TaskUpdate>? _sub;

  ItemProgress _snap = const ItemProgress(
    libraryItemId: '',
    status: 'none',
    progress: 0,
    totalTasks: 0,
    completed: 0,
  );

  @override
  void initState() {
    super.initState();
    _dl = ServicesScope.of(context).services.downloads;
    // Seed once
    _dl.watchItemProgress(widget.libraryItemId).listen((s) {
      if (!mounted) return;
      setState(() => _snap = s);
    });
    // Also listen to global updates so the button repaints quickly
    _sub = _dl.progressStream().listen((_) {});
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final running = _snap.status == 'running' || _snap.status == 'queued';
    final completed = _snap.status == 'complete';

    if (running) {
      return FilledButton.tonalIcon(
        onPressed: () => _dl.cancelForItem(widget.libraryItemId),
        icon: const Icon(Icons.close),
        label: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            const Text('Cancel'),
            const SizedBox(width: 8),
            SizedBox(
              width: 42,
              height: 6,
              child: ClipRRect(
                borderRadius: BorderRadius.circular(3),
                child: LinearProgressIndicator(value: _snap.progress == 0 ? null : _snap.progress),
              ),
            ),
          ],
        ),
      );
    }

    if (completed) {
      return FilledButton.tonalIcon(
        onPressed: () async {
          final ok = await showDialog<bool>(
            context: context,
            builder: (ctx) => AlertDialog(
              title: const Text('Delete downloads?'),
              content: const Text('Remove downloaded files for this book?'),
              actions: [
                TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text('Cancel')),
                FilledButton(onPressed: () => Navigator.pop(ctx, true), child: const Text('Delete')),
              ],
            ),
          ) ??
              false;
          if (ok) {
            await _dl.deleteLocal(widget.libraryItemId);
            if (!mounted) return;
            ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Downloads removed')));
          }
        },
        icon: const Icon(Icons.delete),
        label: const Text('Delete'),
      );
    }

    return FilledButton.icon(
      onPressed: () async {
        await _dl.enqueueItemDownloads(widget.libraryItemId);
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Added to download queue')));
      },
      icon: const Icon(Icons.download),
      label: const Text('Download'),
    );
  }
}

=== ./lib/widgets/mini_player.dart ===
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:just_audio/just_audio.dart';

import '../core/playback_repository.dart';
import '../main.dart';

/// Rich mini player with cover art, title/author, progress and basic controls.
/// Tap it to open the full player (`/player` route).
class MiniPlayer extends StatelessWidget {
  /// Height of the mini player bar.
  final double height;

  /// Backward-compat: older code may pass `playback:`. We ignore it and
  /// resolve playback from ServicesScope, but keep this to avoid compile errors.
  final PlaybackRepository? playback;

  const MiniPlayer({super.key, this.height = 96, this.playback});

  @override
  Widget build(BuildContext context) {
    // Prefer ServicesScope; fall back to provided playback if ever needed.
    final pb = ServicesScope.of(context).services.playback;
    final cs = Theme.of(context).colorScheme;

    return Material(
      elevation: 12,
      color: cs.surface,
      child: SizedBox(
        height: height,
        child: InkWell(
          onTap: () => Navigator.of(context).pushNamed('/player'),
          child: StreamBuilder<NowPlaying?>(
            stream: pb.nowPlayingStream,
            initialData: pb.nowPlaying,
            builder: (_, npSnap) {
              final np = npSnap.data;
              if (np == null) {
                return Center(
                  child: Text(
                    'Nothing playing',
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                );
              }

              return Padding(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                child: Row(
                  children: [
                    // Cover
                    ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: CachedNetworkImage(
                        imageUrl: np.coverUrl ?? '',
                        width: height - 16,
                        height: height - 16,
                        fit: BoxFit.cover,
                        errorWidget: (_, __, ___) => Container(
                          width: height - 16,
                          height: height - 16,
                          color: cs.surfaceContainerHighest,
                          child: const Icon(Icons.audiotrack),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),

                    // Title / author + progress
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(np.title,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context).textTheme.titleMedium),
                          const SizedBox(height: 2),
                          Text(np.author ?? '',
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context).textTheme.bodySmall),
                          const Spacer(),
                          StreamBuilder<Duration?>(
                            stream: pb.durationStream,
                            initialData: pb.player.duration,
                            builder: (_, dSnap) {
                              final total = dSnap.data ?? Duration.zero;
                              return StreamBuilder<Duration>(
                                stream: pb.positionStream,
                                initialData: pb.player.position,
                                builder: (_, pSnap) {
                                  final pos = pSnap.data ?? Duration.zero;
                                  final v = (total.inMilliseconds > 0)
                                      ? pos.inMilliseconds / total.inMilliseconds
                                      : 0.0;
                                  return LinearProgressIndicator(value: v);
                                },
                              );
                            },
                          ),
                        ],
                      ),
                    ),

                    const SizedBox(width: 8),

                    // Controls
                    StreamBuilder<bool>(
                      stream: pb.playingStream,
                      initialData: pb.player.playing,
                      builder: (_, playSnap) {
                        final playing = playSnap.data ?? false;
                        return Row(
                          children: [
                            IconButton(
                              tooltip: 'Rewind 10s',
                              icon: const Icon(Icons.replay_10),
                              onPressed: () => pb.nudgeSeconds(-10),
                            ),
                            IconButton(
                              tooltip: playing ? 'Pause' : 'Play',
                              icon: Icon(playing ? Icons.pause : Icons.play_arrow),
                              onPressed: () => playing ? pb.pause() : pb.resume(),
                            ),
                            IconButton(
                              tooltip: 'Forward 30s',
                              icon: const Icon(Icons.forward_30),
                              onPressed: () => pb.nudgeSeconds(30),
                            ),
                          ],
                        );
                      },
                    ),
                  ],
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}

=== ./.dart_tool/flutter_build/dart_plugin_registrant.dart ===
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.7

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite_android/sqflite_android.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:flutter_secure_storage_windows/flutter_secure_storage_windows.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteAndroid.registerWith();
      } catch (err) {
        print(
          '`sqflite_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FlutterSecureStorageWindows.registerWith();
      } catch (err) {
        print(
          '`flutter_secure_storage_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}

